### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type BusinessUnit {
  company: Company!
  id: ID!
  name: String!
  projectProfiles(after: ID, before: ID, first: Int, last: Int, skip: Int): [ProjectProfile!]!
}

input BusinessUnitFilter {
  every: BusinessUnitWhereInput
  none: BusinessUnitWhereInput
  some: BusinessUnitWhereInput
}

input BusinessUnitWhereInput {
  AND: [BusinessUnitWhereInput!]
  company: CompanyWhereInput
  id: StringFilter
  name: StringFilter
  NOT: [BusinessUnitWhereInput!]
  OR: [BusinessUnitWhereInput!]
  projectProfiles: ProjectProfileFilter
}

type Company {
  businessUnits(after: ID, before: ID, first: Int, last: Int, skip: Int): [BusinessUnit!]!
  id: ID!
  name: String!
  projects(after: ID, before: ID, first: Int, last: Int, skip: Int): [Project!]!
  users(after: ID, before: ID, first: Int, last: Int, skip: Int): [User!]!
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  businessUnits: BusinessUnitFilter
  id: StringFilter
  name: StringFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  projects: ProjectFilter
  users: UserFilter
}

input CreateProjectInput {
  name: String!
  ownerId: String!
}

input CreateProjectProfileInput {
  businessUnitId: String!
}

input CreateProjectProfilesInput {
  projectProfiles: [CreateProjectProfileInput!]!
  projectUrl: String!
}

input CreateSpendsInput {
  projectProfileId: String!
  spendAmountsAndDates: [SpendAmountAndDateInput!]!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  createProject(input: CreateProjectInput!): Project!
  createProjectProfiles(input: CreateProjectProfilesInput!): [ProjectProfile!]!
  createSpends(input: [CreateSpendsInput!]!): [ProjectProfile!]!
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

enum OrderByArg {
  asc
  desc
}

type Project {
  company: Company!
  createdAt: DateTime!
  id: ID!
  name: String!
  owner: User!
  projectProfiles(after: ID, before: ID, first: Int, last: Int, skip: Int, where: ProjectProjectProfilesWhereInput): [ProjectProfile!]!
  totalBaselineSpend: Int!
  totalForecastedSavingAmount: Int!
  totalForecastedSavingPercentage: Int!
  url: String!
}

input ProjectFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

type ProjectProfile {
  businessUnit: BusinessUnit!
  id: ID!
  project: Project!
  spend(after: ID, before: ID, first: Int, last: Int, orderBy: ProjectProfileSpendOrderByInput, skip: Int): [Spend!]!
}

input ProjectProfileFilter {
  every: ProjectProfileWhereInput
  none: ProjectProfileWhereInput
  some: ProjectProfileWhereInput
}

input ProjectProfileSpendOrderByInput {
  month: OrderByArg
}

input ProjectProfileWhereInput {
  AND: [ProjectProfileWhereInput!]
  businessUnit: BusinessUnitWhereInput
  id: StringFilter
  NOT: [ProjectProfileWhereInput!]
  OR: [ProjectProfileWhereInput!]
  project: ProjectWhereInput
  spend: SpendFilter
}

input ProjectProjectProfilesWhereInput {
  businessUnit: BusinessUnitWhereInput
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  company: CompanyWhereInput
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  owner: UserWhereInput
  projectProfiles: ProjectProfileFilter
  url: StringFilter
}

input ProjectWhereUniqueInput {
  id: ID
  url: String
}

type Query {
  businessUnits(after: ID, before: ID, first: Int, last: Int, orderBy: QueryBusinessUnitsOrderByInput, skip: Int): [BusinessUnit!]!
  project(where: ProjectWhereUniqueInput!): Project
  projectProfiles(after: ID, before: ID, first: Int, last: Int, skip: Int, where: QueryProjectProfilesWhereInput): [ProjectProfile!]!
  projects(after: ID, before: ID, first: Int, last: Int, orderBy: QueryProjectsOrderByInput, skip: Int, where: QueryProjectsWhereInput): [Project!]!
  reportTableData(input: ReportDataTableInput!): [ReportTableData!]!
  user(where: UserWhereUniqueInput!): User
  users(after: ID, before: ID, first: Int, last: Int, skip: Int): [User!]!
}

input QueryBusinessUnitsOrderByInput {
  name: OrderByArg
}

input QueryProjectProfilesWhereInput {
  project: ProjectWhereInput
}

input QueryProjectsOrderByInput {
  name: OrderByArg
}

input QueryProjectsWhereInput {
  url: StringFilter
}

input ReportDataTableInput {
  businessUnitIds: [String!]!
  dataType: ReportDataType!

  """timestamp in milliseconds"""
  endPeriod: String!
  projectIds: [String!]!

  """timestamp in milliseconds"""
  startPeriod: String!
}

enum ReportDataType {
  ActualSavings
  BaselineSpend
  ForecastedSavingsAmount
  ForecastedSavingsPercentage
}

type ReportTableData {
  data: [ReportTableRowData!]!
  id: String!
  projectName: String!
  projectUrl: String!
}

type ReportTableRowData {
  amount: Int!
  columnId: String!
  columnName: String!
  id: String!
}

type Spend {
  actualSavings: Int
  baselineSpend: Int!
  forecastedSavingsAmount: Int!
  forecastedSavingsPercentage: Int!
  id: ID!
  month: DateTime!
  projectProfile: ProjectProfile!
}

input SpendAmountAndDateInput {
  actualSavings: Int
  baselineSpend: Int!
  forecastedSavings: Int!

  """dateString format"""
  month: String!
}

input SpendFilter {
  every: SpendWhereInput
  none: SpendWhereInput
  some: SpendWhereInput
}

input SpendWhereInput {
  actualSavings: NullableIntFilter
  AND: [SpendWhereInput!]
  baselineSpend: IntFilter
  forecastedSavingsAmount: IntFilter
  id: StringFilter
  month: DateTimeFilter
  NOT: [SpendWhereInput!]
  OR: [SpendWhereInput!]
  projectProfile: ProjectProfileWhereInput
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  company: Company!
  firstName: String!
  fullName: String!
  id: ID!
  lastName: String!
  projects(after: ID, before: ID, first: Int, last: Int, orderBy: UserProjectsOrderByInput, skip: Int): [Project!]!
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserProjectsOrderByInput {
  createdAt: OrderByArg
}

input UserWhereInput {
  AND: [UserWhereInput!]
  company: CompanyWhereInput
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  projects: ProjectFilter
}

input UserWhereUniqueInput {
  id: ID
}
